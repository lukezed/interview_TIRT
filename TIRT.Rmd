```{r}
library(MASS)
library(tidyverse)
library(brms)
library(Matrix)
library(patchwork)
```

```{r}
set.seed(2026)

# --- 1. Latent Structure: 6x6 Correlation Matrix ---
v_names <- c("La", "Lr", "Sa", "Sr", "Pa", "Pr")
rho_mat <- matrix(0.1, 6, 6); diag(rho_mat) <- 1

# Define Core Conflicts (Phi) and Trait Consistency (0.6)
rho_mat[1,2] <- rho_mat[2,1] <- -0.2 # L: a-r conflict
rho_mat[3,4] <- rho_mat[4,3] <- -0.5 # S: a-r conflict
rho_mat[5,6] <- rho_mat[6,5] <- -0.8 # P: a-r conflict
rho_mat[c(1,3,5), c(1,3,5)] <- 0.6    # Autonomy consistency
rho_mat[c(2,4,6), c(2,4,6)] <- 0.6    # Relatedness consistency

# Stabilize Matrix
rho_stable <- as.matrix(nearPD(rho_mat, corr = TRUE)$mat)
rownames(rho_stable) <- colnames(rho_stable) <- v_names

# --- 2. Population: Noisy Latent Traits ---
n <- 200
theta_raw <- mvrnorm(n, rep(0, 6), rho_stable)
# Add individual jitter (noise) to the generated traits
theta_jitter <- theta_raw + matrix(rnorm(n * 6, 0, 0.1), n, 6)

theta <- as.data.frame(theta_jitter) %>% set_names(v_names) %>%
  mutate(ID = 1:n(), comm = rep(c("G", "N"), each = n/2)) %>%
  # Apply community bias with individual-level variation
  mutate(across(c(La, Sa, Pa), ~ .x + if_else(comm == "N", -0.5, 0.5) + rnorm(n(), 0, 0.1)),
         across(c(Lr, Sr, Pr), ~ .x + if_else(comm == "N", 0.5, -0.5) + rnorm(n(), 0, 0.1)))

# --- 3. Items & Responses: 1PL RSM (acat) Logic ---
items <- expand.grid(Domain = c("L", "S", "P"), Trait = c("dim_a", "dim_r"), rep = 1:5) %>%
  mutate(item = paste0(Domain, if_else(Trait == "dim_a", "a", "r"), rep), 
         diff = runif(n(), -1.5, 1.5))

tau <- c(-1.5, 0, 1.5) 

simdata <- theta %>%
  pivot_longer(La:Pr, names_to = "key", values_to = "ab") %>%
  mutate(
    Domain = str_sub(key, 1, 1), 
    Trait  = if_else(str_detect(key, "a$"), "dim_a", "dim_r"),
    dim_a  = if_else(Trait == "dim_a", 1, 0),
    dim_r  = if_else(Trait == "dim_r", 1, 0)
  ) %>%
  left_join(items, by = c("Domain", "Trait"), relationship = "many-to-many") %>%
  rowwise() %>%
  mutate(
    ind_opt_bias = if_else(comm == "N", rnorm(1, 0.6, 0.1), 0),
    eta = (ab - diff) + ind_opt_bias + rnorm(1, 0, 0.4),
    
    f0 = 1,
    f1 = exp(eta - tau[1]),
    f2 = exp(2*eta - (tau[1] + tau[2])),
    f3 = exp(3*eta - (tau[1] + tau[2] + tau[3])),
    sum_f = f0 + f1 + f2 + f3,
    resp = sample(0:3, 1, prob = c(f0, f1, f2, f3) / sum_f) + 1
  ) %>%
  ungroup() %>%
  select(ID, comm, Domain, item, resp, dim_a, dim_r)

write_csv(simdata, "data/simdata.csv")
```



```{r}
fit <- brm(
  formula = resp ~ 1 + comm + (0 + dim_a + dim_r | ID) + (1 | item),
  data = simdata,
  family = brmsfamily("acat", "logit"), 
  prior = c(
    prior(normal(0, 3), class = "b"), 
    prior(normal(0, 1), class = "sd"),
    prior(lkj(2), class = "cor")
  ),
  backend = "cmdstanr", chains = 4, iter = 2000, warmup = 1000, cores = 4,
  file = "models/fit_rsm"
)

summary(fit)
```
```{r}
get_re_ranked <- function(model, trait_name) {
  id_info <- simdata %>% distinct(ID, comm) %>% mutate(ID = as.character(ID))
  ranef(model)$ID[, , trait_name] %>%
    as_tibble(rownames = "ID") %>%
    left_join(id_info, by = "ID") %>%
    arrange(Estimate) %>%
    mutate(rank = row_number(), trait = trait_name)
}

# Combine ability data for faceting
id_re_long <- bind_rows(get_re_ranked(fit, "dim_a"), get_re_ranked(fit, "dim_r"))
# Get item data
it_re <- ranef(fit)$item[, , 1] %>% as_tibble(rownames = "item") %>% mutate(dim = str_sub(item, 1, 1))


# --- 2. Define BÃ¼rkner-style Theme ---
theme_burkner <- theme_bw() +
  theme(
    panel.grid = element_blank(),
    text = element_text(size = 9, family = "serif"),
    strip.background = element_rect(fill = "#E0E0E0", color = "black", linewidth = 0.5),
    strip.text = element_text(color = "black", size = 10, hjust = 0.5),
    legend.position = "right",
    legend.box.just = "top",
    legend.margin = margin(l = 10),
    aspect.ratio = 1.4
  )
colors_comm <- c("G" = "#D55E00", "N" = "#0072B2")


# --- 3. Create Plots with Facet Strips ---

# P1: Item Difficulty
# Trick: Add a dummy column to use facet_wrap for the strip title
p1 <- it_re %>%
  mutate(panel_title = "Item Difficulty") %>%
  ggplot(aes(x = Estimate, y = item, color = dim)) +
  geom_point(size = 1.5) +
  geom_errorbar(aes(xmin = Q2.5, xmax = Q97.5), width = 0.4) +
  facet_wrap(~panel_title) + # This creates the gray strip
  labs(x = "Logit", y = NULL, color = "Domain") +
  theme_burkner

# P2: Combined Abilities
# Define better labels for the facet titles
trait_labeller <- as_labeller(c(
  "dim_a" = "Ability: dim_a",
  "dim_r" = "Ability: dim_r"
))

# Plot combined data, faceted by trait
p_ability <- ggplot(id_re_long, aes(x = Estimate, y = rank, color = comm)) +
  geom_point(alpha = 0.8, size = 1) +
  geom_errorbar(aes(xmin = Q2.5, xmax = Q97.5), alpha = 0.8) +
  facet_wrap(~trait, labeller = trait_labeller) + # Facet creates the two panels with strips
  scale_color_manual(values = colors_comm) +
  labs(x = "Logit", color = "Community") +
  theme_burkner


# --- 4. Combine and Save ---
# Combine the single-panel plot (p1) and the two-panel plot (p_ability)
# Set widths to 1:2 so the ability panels are the same size as the item panel
fig_final <- p1 + p_ability +
  plot_layout(ncol = 2, widths = c(1, 2), guides = "collect")

print(fig_final)

ggsave("figures/fig_rsm_recovery.pdf", fig_final, width = 8, height = 5, device = cairo_pdf)
ggsave("figures/fig_rsm_recovery.png", fig_final, width = 8, height = 5, dpi = 2000)

```



```{r}

ce_default <- conditional_effects(fit, effects = "comm")
ce_cat     <- conditional_effects(fit, effects = "comm", categorical = TRUE)


p1_native <- plot(ce_default, plot = FALSE)[[1]]
p2_native <- plot(ce_cat, plot = FALSE)[[1]]


fig_comm_effects <- p1_native | p2_native


print(fig_comm_effects)
ggsave("figures/fig_comm_effects.png", fig_comm_effects, width = 8, height = 5, dpi = 2000)

```



```{r}
fit_sep <- brm(
 formula = resp ~ 1 + comm + (0 + Domain:dim_a + Domain:dim_r | ID) + (1 | item),
  data = simdata,
  family = brmsfamily("acat", "logit"), 
  prior = c(
    prior(normal(0, 1), class = "sd"),
    prior(lkj(2), class = "cor")
  ),
  chains = 4, iter = 2000, warmup = 1000, cores = 4, backend = "cmdstanr",
  file = "models/fit_sep_dim"
)

summary(fit_sep)
```


```{r}

raw_3d <- VarCorr(fit_sep)$ID$cor
phys_idx <- c(1, 4, 3, 6, 2, 5) # La, Lr, Sa, Sr, Pa, Pr
target_labels <- c("La", "Lr", "Sa", "Sr", "Pa", "Pr")

phi_matrix <- raw_3d[phys_idx, 1, phys_idx]
colnames(phi_matrix) <- rownames(phi_matrix) <- target_labels

hyper_labels <- data.frame(
  Domain = c("L", "P", "S"),
  rho_val = c(
    phi_matrix["La", "Lr"], 
    phi_matrix["Pa", "Pr"], 
    phi_matrix["Sa", "Sr"]
  )
) %>%
  mutate(
    label = sprintf("rho == %.2f", rho_val),
    x_pos = -2.0, 
    y_pos = 2.2
  )

re_raw <- ranef(fit_sep)$ID
plot_df <- as.data.frame.table(re_raw) %>%
  rename(ID = Var1, Stat = Var2, Param = Var3, Val = Freq) %>%
  mutate(
    ID = as.character(ID),
    Domain = str_extract(Param, "L|S|P"),
    Trait = if_else(str_detect(Param, "dim_a"), "a", "r")
  ) %>%
  filter(!is.na(Domain), Stat %in% c("Estimate", "Q2.5", "Q97.5")) %>%
  select(ID, Domain, Trait, Stat, Val) %>%
  pivot_wider(names_from = c(Trait, Stat), values_from = Val, names_sep = "_") %>%
  inner_join(
    simdata %>% distinct(ID, comm) %>% mutate(ID = as.character(ID)), 
    by = "ID"
  )

fig3 <- ggplot(plot_df, aes(x = a_Estimate, y = r_Estimate, color = Domain)) +
  geom_errorbar(aes(xmin = a_Q2.5, xmax = a_Q97.5), alpha = 0.1, linewidth = 0.2) +
  geom_errorbar(aes(ymin = r_Q2.5, ymax = r_Q97.5), alpha = 0.1, linewidth = 0.2) +
  
  geom_smooth(aes(fill = Domain), method = "lm", color = "black", 
              linewidth = 0.5, alpha = 0.1, linetype = "dashed") +
  
  geom_point(aes(shape = comm), alpha = 0.6, size = 1.3) +
  
  geom_text(data = hyper_labels, 
            aes(x = x_pos, y = y_pos, label = label), 
            color = "black", size = 3, fontface = "italic", 
            parse = TRUE, inherit.aes = FALSE) +
  

  facet_wrap(~Domain) +
  scale_color_manual(values = c("L" = "#E69F00", "S" = "#56B4E9", "P" = "#009E73")) +
  scale_fill_manual(values = c("L" = "#E69F00", "S" = "#56B4E9", "P" = "#009E73")) +
  scale_shape_manual(values = c("G" = 1, "N" = 17)) +
  labs(x = "dim_a", y = "dim_r") +
  theme_bw() +
  theme(
    panel.grid = element_blank(),
    text = element_text(size = 10, family = "serif"),
    strip.background = element_rect(fill = "#E0E0E0", color = "black", linewidth = 0.8),
    strip.text = element_text(face = "bold", size = 10),
    legend.position = "bottom",
    aspect.ratio = 1
  )


ggsave("figures/fig_sep_scatter.png", fig3, width = 9, height = 5, dpi = 2000)
```
```{r}


target_indices <- c(1, 4, 3, 6, 2, 5)
target_labels  <- c("La", "Lr", "Sa", "Sr", "Pa", "Pr")


raw_cor_3d <- VarCorr(fit_sep)$ID$cor

phi_sim_full <- raw_cor_3d[, 1, ]

# Reorder both rows and columns to match target_labels
phi_sim <- phi_sim_full[target_indices, target_indices]
colnames(phi_sim) <- rownames(phi_sim) <- target_labels

# --- 2. Data Preparation: Lower Triangle (Excluding Diagonal) ---

prepare_tri_data <- function(mat, source_label) {
  mat %>%
    as.data.frame.table() %>%
    rename(V1 = Var1, V2 = Var2, Cor = Freq) %>%
    mutate(
      V1 = factor(V1, levels = target_labels),
      V2 = factor(V2, levels = target_labels),
      # Filter for lower triangle: Row numeric index > Col numeric index
      is_lower = as.numeric(V1) > as.numeric(V2),
      Source = source_label
    ) %>%
    filter(is_lower)
}

# Process Simulation and Truth (rho_stable)
df_sim   <- prepare_tri_data(phi_sim, "Simulation (Estimated)")
df_truth <- prepare_tri_data(rho_stable, "Truth Value (Target)")

# Combine and reverse Y-axis levels so 'La' starts at the top
plot_df <- bind_rows(df_sim, df_truth) %>%
  mutate(V2 = factor(V2, levels = rev(target_labels)))

# --- 3. High-Contrast Visualization ---

fig4 <- ggplot(plot_df, aes(x = V1, y = V2, fill = Cor)) +
  # Use thick white grid lines to emphasize the 6x6 structure
  geom_tile(color = "white", linewidth = 1) +
  # Add labels with dynamic color based on tile intensity
  geom_text(aes(label = sprintf("%.2f", Cor), 
                color = abs(Cor) > 0.5), size = 3.5, fontface = "bold") +
  scale_color_manual(values = c("TRUE" = "white", "FALSE" = "black"), guide = "none") +
  
  # High Contrast: Saturated Red (#B22222) and Green (#006400)
  scale_fill_gradient2(low = "#B22222", mid = "white", high = "#006400", 
                       midpoint = 0, limit = c(-1, 1), name = "Phi") +
  
  facet_wrap(~Source) +
  
  # Force 6x6 axes to remain visible even with empty cells
  scale_x_discrete(drop = FALSE, expand = c(0,0)) +
  scale_y_discrete(drop = FALSE, expand = c(0,0)) +
  
  theme_bw() +
  theme(
    text = element_text(size = 9, family = "serif"),
    panel.grid = element_blank(),
    axis.title = element_blank(),
    axis.text = element_text(color = "black", size = 9, face = "bold"),
    strip.background = element_rect(fill = "#E0E0E0", color = "black", linewidth = 1.2),
    strip.text = element_text(face = "bold", size = 9),
    aspect.ratio = 1
  )


ggsave("figures/fig_phi_heatmap.png", fig4, width = 9, height = 5, dpi = 2000)
```
```{r}
library(tidyverse)
library(brms)

# --- 1. Robust Physical Extraction (Based on 6x4x6 Diagnostic) ---

# Define the target order for comparison: La, Lr, Sa, Sr, Pa, Pr
target_labels <- c("La", "Lr", "Sa", "Sr", "Pa", "Pr")

# Mapping the physical indices from your diagnostic output:
# 1:La, 4:Lr, 3:Sa, 6:Sr, 2:Pa, 5:Pr
phys_idx <- c(1, 4, 3, 6, 2, 5)

# Extract 3D array: [Row, Stat, Col]
raw_3d <- VarCorr(fit_sep)$ID$cor

# Select Posterior Mean (Column 1 of dimension 2) and reorder to target_labels
# phi_est_mat will be a clean 6x6 matrix
phi_est_mat <- raw_3d[phys_idx, 1, phys_idx]
colnames(phi_est_mat) <- rownames(phi_est_mat) <- target_labels

# --- 2. Vectorization (Simulation vs Truth) ---

# Helper to get unique lower triangle values (15 correlations)
get_tri_vec <- function(m) {
  # Force to matrix and return the values below the diagonal
  return(as.matrix(m)[lower.tri(as.matrix(m))])
}

# Vector 1: Estimated correlations from fit_sep
v_est   <- get_tri_vec(phi_est_mat)

# Vector 2: True correlations from rho_stable
# Ensure rho_stable is ordered correctly before vectorizing
v_truth <- get_tri_vec(rho_stable)

# --- 3. Parameter Recovery Metrics ---

# Check for NAs one last time
if(any(is.na(v_est))) stop("Extraction failed: Data still contains NAs.")

phi_bias <- mean(v_est - v_truth)
phi_rmse <- sqrt(mean((v_est - v_truth)^2))
phi_rel  <- cor(v_est, v_truth)

# --- 4. Final Result Table ---

recovery_table <- data.frame(
  Parameter = "Latent Correlation (Phi)",
  Mean_Bias = round(phi_bias, 4),
  RMSE      = round(phi_rmse, 4),
  Rel_Val   = round(phi_rel, 4)
)

print(recovery_table)
```

